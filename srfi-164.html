<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>SRFI 164: Enhanced multi-dimensional Arrays</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/srfi.css" type="text/css" />
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
  div.title h1 { font-size: small; color: blue }
  div.title { font-size: xx-large; color: blue; font-weight: bold }
  h1 { font-size: x-large; color: blue }
  h2 { font-size: large; color: blue }
  h3 { color: blue }
  /* So var inside pre gets same font as var in paragraphs. */
  var { font-family: monospace; }
  em.non-terminal { }
  em.non-termina-def { }
  code.literal { font-style: normal; }
/*  code.literal:before { content: "“" }  code.literal:after { content: "”" } */
  span.proc-def { font-weight: bold }
  code.function { font-weight: bold }
  p.synopsis { background-color: #DCffDC }
  p { margin: 0.5ex }
  blockquote { margin-top: 0.5ex }
</style>
  </head>

<body>
<div class="title">
<h1>Title</h1>
Enhanced multi-dimensional Arrays
</div>

<h1>Author</h1>
Per Bothner

<h1>Status</h1>

<p>This SRFI is currently in <em>draft</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+164+at+srfi+dotschemers+dot+org">srfi-164@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-164">archive</a>.</p>
<ul>
  <li>Received: 2018/11/2</li>
  <li>60-day deadline: 2019/1/1</li>
  <li>Draft #1 published: 2018/11/2</li>
  <li>Draft #2 published: 2018/11/17</li>
  <li>Draft #3 published: 2018/12/7</li>
</ul>

<h1>Abstract</h1>
<p>This SRFI describes the array data type (a generalization of vectors
to multiple indexes or dimensions), along with a set of procedures
for working on them.
<p>This specification is an extension of <a class="ulink" href="http://srfi.schemers.org/srfi-25/srfi-25.html" target="_top">SRFI 25</a>,
with additions from Racket’s
<a class="ulink" href="https://docs.racket-lang.org/math/array.html" target="_top">math.array</a> package
and other sources.
It has been implemented in the
<a href="https://www.gnu.org/software/kawa/Arrays.html">Kawa dialect of Scheme</a>.

<h1>Issues</h1>
<ul>
<li>
The Rationale section is empty.
<li>
The Acknowledgements section is empty.
<li>
The range API is new and untested.  Some changes (including function names) may not make sense.
It may make sense to move it into a separate SRFI.
<li>
Right now we have shape-specifiers, and the SRFI 4 <code>shape</code>
procedure, which creates one kind of shape-specifier.
However, there is no <code>array-shape</code> procedure to
return a shape as a single object.
Instead, there are the <code>array-rank</code>,
<code>array-start</code>, and <code>array-end</code> procedures
to <q>inspect</q> the shape.  Is that enough?
Should we have an explicit <q>shape</q> type?
(This is essentially the <q>interval</q> type of SRFI 122.)
Should it be a distinct opaque type, or one of the shape specifier types?
<li>
Any important missing procedures?
It might be useful to have <code>array-copy</code>,
though if we have <code>array-shape</code>
then <code>(array-copy arr)</code> is trivially
defined as <code>(array-reshape (array-flatten arr) (array-shape arr))</code>.
An <code>array-map</code> seems useful; APL-style "rank extension"
may be useful but tricky.
<li>Need alternate non-Kawa way to expression pseudo-ranges.
<li>Any other Kawa-isms that need to be removed?
</ul>

<h1>Rationale</h1>

<h1>Specification</h1>
<p>
<p>Arrays are heterogeneous data structures that generalize vectors to multiple
indexes or dimensions.  Instead of a single integer index,
there are multiple indexes:  An index is a vector of integers;
the length of a valid index sequence
is the rank or the number of dimensions of an array.
<p>
A <dfn>generalized vector</dfn> is a standard vector,
but (depending on implementation) can also include uniform vectors,
bytevectors, ranges, and strings (viewed as vectors of characters).
Arrays are an extension of vectors:
An array whose rank is 1, and where the (single) lower bound is 0
is a (generalized) vector.
A library-based implementation of this specification should use
the existing (generalized) vector type
for "simple" rank-1 zero-lower-bound arrays
(not created by <code class="literal">share-array</code>).
</p>
<p>A rank-0 array has a single value.  It is essentially a box for that
value.  Functions that require arrays may treat non-arrays
as rank-0 arrays containing that value.
</p>
<p>An array of rank 2 is frequently called a <em class="firstterm">matrix</em>.
</p>
<p>
  Arrays may be mutable or immutable.</p>
<p>
The examples use the array literal syntax and <code>format-array</code> helper function
of <a href="https://srfi.schemers.org/srfi-163/srfi-163.html">SRFI 163</a>
for illustrative purposes.
However, this specification does not require SRFI 163 (or vice versa),
though they are designed to work well together.
<p>
<p class="synopsis" kind="Procedure"><code class="function">(array?</code> <var>obj</code></var>)</code></p>
<div class="blockquote"><blockquote class="blockquote"><p>Returns <code class="literal">#t</code> if <var>obj</var> is an array, otherwise returns <code class="literal">#f</code>.
Note this also returns true for a (generalized) vector.
</p></blockquote></div>

<div class="sect2">
<h3 id="Ranges">Ranges</h3>
<em>This should/could be moved out to a separate SRFI.</em>
<p>
A range has a lower bound, an upper bound, and a step that defaults to 1.
It is a new type of immutable generalized vector with an optimized, compact representation.
<p>
A <dfn>range</dfn> is an immutable sequence of values that increase <q>linearly,</q> i.e. by a fixed amount (the <dfn>step</dfn>)
between each element.</p>
<div kind="Procedure"><p class="synopsis"><code class="function">(range-from</code> <var>start</var> [<var>step</var>]<code>)</code><p>
<blockquote class="blockquote"><p>Creates an <dfn>unbounded</dfn> or non-finite range, where <em>step</em> defaults to 1.
The result is an infinite sequence of values, starting with <var>start</var>, and followed by
<code class="literal">(+ <var>start</var> <var>step</var>)</code>,
<code class="literal">(+ <var>start</var> (* 2 <var>step</var>))</code>, and so on.
For example, <code>(range-from 3 2)</code> is the odd integers starting at 3.</p></blockquote></div>
<div kind="Procedure"><p class="synopsis" kind="Procedure"><code class="function">(range&lt;</code> <var>end</var> [<var>start</var> [<var>step</var>]]<code>)</code></p>
<p class="synopsis" kind="Procedure"><code class="function">(range&lt;=</code> <var>end</var> [<var>start</var> [<var>step</var>]]<code>)</code></p>
<blockquote><p>
In these cases, the sequence counts up: The <em class="replaceable">step</em> must be positive, and defaults to 1,
while <em class="replaceable">start</em> defaults to 0.
The resulting values are the initial subsequence of <code>(range-from <var>start</code> <var>step</var>)</code> as long as the value <var>x</var> satisfies <code class="literal">(&lt; <var>x</var> <var>end</var>)</code>,
or <code class="literal">(&lt;= <var>x</var> <var>end</var>)</code>, respectively.
<em>(Note: It might be more useful in the <code>range&lt;=</code> case for <em class="replaceable">start</em> to default to 1,
but consistency is probably more desirable.)</em>
</p></blockquote></div>
<div kind="Procedure">
<p class="synopsis"><code class="function">(range&gt;</code> <var>end</var> <var>start</var> [<var>step</var>]<code>)</code><p>
<p class="synopsis"><code class="function">(range&gt;=</code> <var>end</var> <var>start</var> [<var>step</var>]<code>)</code><p>
<blockquote class="blockquote"><p>
In these cases, the sequence counts down: The <em class="replaceable"><code>step</code></em> must be negative, and defaults to -1.
The resulting values are those  <var>x</var> such that <code class="literal">(&gt; <var>x</var> <var>end</var>)</code>,
  or  <code class="literal">(&gt;= <em class="replaceable"><code>x</code></em> <em class="replaceable"><code>end</code></em>)</code>, respectively.
<p/></blockquote>
</div>
<div kind="Procedure"><p class="synopsis" kind="Procedure"> <code class="function">(range-take</code> <var>count</var> [<var>start</var> [<var>step</var>]]<code>)</code></p>
<blockquote><p>
In this case, the resulting range is the first <var>count</var> elements of the unbounded sequence.
The expression <code>(range-take <var>count</var> <var>start</var> <var>step</var>)</code>
yields the same sequence as SRFI 1's <code>(iota <var>count</var> <var>start</var> <var>step</var>)</code>.
</p></blockquote></div>
<div kind="Procedure"><p class="synopsis" kind="Procedure"> <code class="function">(range-start</code> <var>range</var><code>)</code></p>
<blockquote><p>Return the <var>start</var> value of the range.
</p></blockquote></div>
<div kind="Procedure"><p class="synopsis" kind="Procedure"> <code class="function">(range-step</code> <var>range</var><code>)</code></p>
<blockquote><p>Return the <var>step</var> value of the range.
</p></blockquote></div>
<div kind="Procedure"><p class="synopsis" kind="Procedure"> <code class="function">(range-length</code> <var>range</var><code>)</code></p>
<blockquote><p>Return the number of values (the <var>count</var>) of the range,
if finite.  If unbounded, return <code>#f</code>.
</p></blockquote></div><p>
  <div kind="Procedure"><p class="synopsis" kind="Procedure"> <code class="function">(range-ref</code> <var>range</var> <var>index</var><code>)</code></p>
<blockquote>
<p>If is an error if <var>index</var> is not an exact non-negative integer, or
if <code>(range-length <var>range</var>)</code>
is an integer (not <code>#f</code>) and greater than or equal to <var>index</var>.
Otherwise, returns <code>(+ <var>start</var> (* <var>index</var> </var>step</var>))</code>.
</p></blockquote></div>
<p>It is convenient but not required that standard vector procedures
such as <code>vector-map</code> be extended to work on ranges.
In that case, <code>vector-ref</code> on a range should be
the same as <code>range-ref</code>.
<p>This specification is based on <a href="https://www.gnu.org/software/kawa/Ranges.html">Kawa's range type</a>,
though Kawa has a prettier syntax.
</div>

<div class="sect2">
<h3 id="Array-shape">Array shape</h3>
<p>The <em class="firstterm">shape</em> of an array consists of bounds for each index.
</p>
<p>The lower bound <em class="replaceable"><code>b</code></em> and the upper bound <em class="replaceable"><code>e</code></em> of a dimension are
exact integers with <code class="literal">(&lt;= <em class="replaceable"><code>b</code></em> <em class="replaceable"><code>e</code></em>)</code>. A valid index along the
dimension is an exact integer <em class="replaceable"><code>i</code></em> that satisfies both
<code class="literal">(&lt;= <em class="replaceable"><code>b</code></em> <em class="replaceable"><code>i</code></em>)</code> and <code class="literal">(&lt; <em class="replaceable"><code>i</code></em> <em class="replaceable"><code>e</code></em>)</code>.
The length of the array along the dimension is the difference
<code class="literal">(- <em class="replaceable"><code>e</code></em> <em class="replaceable"><code>b</code></em>)</code>.
The size of an array is the product of the lengths of its dimensions.
</p>
<p>A procedure that requires a <em class="replaceable"><code>shape</code></em>
can accept any of the follow <dfn>shape-specifier</dfn> values.
We use as example a 2*3 array with lower bounds 0, and a 3*4 array with lower bounds 1.
</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem"><p>A vector of simple integers.
Each integer <em class="replaceable"><code>e</code></em> is an upper bound,
and is equivalent to the range <code class="literal">(range&lt; <var>e</var>)</code>.
<p>
Examples: <code>#(2 3)</code>, and the second is not expressible.
</p></li>
<li class="listitem"><p>A vector of lists of length 2.
The first element of each list is the lower bound, and the second is the upper bound.
(This variant is not currently implemented in Kawa, but it seems a useful syntax.)
<p>
Examples: <code>#((0 2) (0 3))</code> and <code>#((1 3) (1 4))</code>.
</p></li>
<li class="listitem"><p>A vector of simple ranges, one for each
dimension, all of which are
bounded (finite), consist of integer values,
and have a <em class="replaceable"><code>step</code></em> of 1.
Each range, which is usually written as <code class="literal">(range&lt; <var>e</var> <var>b</var>)</code>
or <code class="literal">(range&lt; <var>e</var>)</code>,
    expresses the bounds of the corresponding dimension.
<p>
Examples: <code>(vector (range&lt; 2) (range&lt;= 2))</code> and <code>(vector (range&lt; 3 1) (range-take 4 1))</code>.
<p>
Using ranges without syntactic sugar can be a bit verbose.
Using the Kawa syntactic sugar, the examples are: <code>[[0 &lt;: 2] [0 &lt;=: 2]]</code> and <code>[[1 &lt;: 3] [1 size: 4]]</code>.)
</p></li>
<li class="listitem"><p>A vector consisting of a mix of integers, length-2 lists, and ranges.
<p>
Examples:  <code>#(2 (0 3))</code> and <code>`#((1 3) ,(range 1 size: 4))</code>.
</p></li>
<li class="listitem"><p>A rank-2 array <em class="replaceable"><code>S</code></em> whose own shape is <code class="literal">#(<var>r</var> 2)</code>.
For each dimension <em class="replaceable"><code>k</code></em>
(where <code class="literal">(&lt;= <em class="replaceable"><code>k</code></em> 0)</code> and <code class="literal">(&lt; <em class="replaceable"><code>k</code></em> <em class="replaceable"><code>r</code></em>)</code>),
the lower bound <em class="replaceable"><code>b<sub>k</sub></code></em> is <code class="literal">(S <em class="replaceable"><code>k</code></em> 0)</code>,
    and the upper bound <em class="replaceable"><code>e<sub>k</sub></code></em> is <code class="literal">(S <em class="replaceable"><code>k</code></em> 1)</code>.
<p>
Examples: <code>#2a((0 2) (0 3))</code> and <code>#2a((1 3) (1 4))</code>.
</p></li>
</ul></div>
<p class="synopsis" kind="Procedure"><code>(<span class="proc-def">shape</span></code> <var>bound</var> <var>...</var><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Returns a shape, in the <code>(<var>r</var> 2)</code> form. The sequence <var>bound</var> ... must consist of an even number
of exact integers that are pairwise not decreasing. Each pair gives the
lower and upper bound of a dimension.
If the shape is used to specify the dimensions of an array
and <em class="replaceable"><code>bound</code></em> ... is the sequence <em class="replaceable"><code>b0</code></em> <em class="replaceable"><code>e0</code></em> ... <em class="replaceable"><code>bk</code></em> <em class="replaceable"><code>ek</code></em>
... of <em class="replaceable"><code>n</code></em> pairs of bounds, then a valid index to the array is any
sequence <em class="replaceable"><code>j0</code></em> ... <em class="replaceable"><code>jk</code></em> ... of <em class="replaceable"><code>n</code></em> exact integers where
each <em class="replaceable"><code>jk</code></em> satisfies <code class="literal">(&lt;= <em class="replaceable"><code>bk</code></em> <em class="replaceable"><code>jk</code></em>)</code>
and <code class="literal">(&lt; <em class="replaceable"><code>jk</code></em> <em class="replaceable"><code>ek</code></em>)</code>.
</p>
<p>The shape of a <em class="replaceable"><code>d</code></em>-dimensional array is a <em class="replaceable"><code>d</code></em> * 2 array
where the element at <em class="replaceable"><code>k 0</code></em> contains the lower bound for an index along
dimension <em class="replaceable"><code>k</code></em> and the element at <em class="replaceable"><code>k 1</code></em> contains the
corresponding upper bound, where <em class="replaceable"><code>k</code></em> satisfies <code class="literal">(&lt;=  0 <em class="replaceable"><code>k</code></em>)</code>
and <code class="literal">(&lt; <em class="replaceable"><code>k</code></em> <em class="replaceable"><code>d</code></em>)</code>.
</p>
<p><code class="literal">(apply shape <em class="replaceable"><code>bounds</code></em>)</code>
is equivalent to:
<code class="literal">(apply array (vector 2 (/ (length <var>bounds</var>) 2)) <var>bounds</var>)</code>
</p>
</blockquote></div>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def" id="array-rank">array-rank</span></code> <var>array</var><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Returns the number of dimensions of <em class="replaceable"><code>array</code></em>.
</p>
<pre class="screen">(array-rank
  (make-array (shape 1 2 3 4)))
</pre>
<p>Returns 2.
</p>
</blockquote></div>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def" id="array-start">array-start</code> <var>array</var> <var>k</var><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote"><p>Returns the lower bound (inclusive) for the index along dimension <em class="replaceable"><code>k</code></em>.
This is most commonly 0.
</p></blockquote></div>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">array-end</span></code> <var>array</var> <var>k</var></code><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote"><p>Returns the upper bound for the index along dimension <em class="replaceable"><code>k</code></em>.
The bound is exclusive - i.e. the first integer higher
than the last legal index.
</p></blockquote></div>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def" id="array-size">array-size</span></code> <var>array</var><code.)</code><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote"><p>Return the total number of elements of <var>array</var>.
This is the product of <code class="literal">(- (array-end <em class="replaceable"><code>array</code></em> <em class="replaceable"><code>k</code></em>) (array-start <em class="replaceable"><code>array</code></em> <em class="replaceable"><code>k</code></em>))</code> for every valid <em class="replaceable"><code>k</code></em>.
</p></blockquote></div>
</div>
<div class="sect2">
<h3 class="title" id="Array-construction"></a>Array construction</h3>
<p>See also <a href="#array-reshape"><code class="literal">array-reshape</code></a>.
</p>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">array</span></code> <em class="replaceable"><code>shape</code></em> <var>obj</var> <var>...</var><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote"><p>Returns a new array whose shape is given by <em class="replaceable"><code>shape</code></em> and the initial
contents of the elements are <em class="replaceable"><code>obj</code></em> ... in row major order. The array does
not retain a reference to <em class="replaceable"><code>shape</code></em>.
</p></blockquote></div>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">make-array</span></code> <var>shape</var><code>)</code></p>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">make-array</span></code> <var>shape</var> <var>value...</var><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Returns a newly allocated array whose shape is given by <em class="replaceable"><code>shape</code></em>.
If <em class="replaceable"><code>value</code></em> is provided, then each element is initialized to it.
If there is more than one <em class="replaceable"><code>value</code></em>, they are used in order, starting
over when the <em class="replaceable"><code>value</code></em>s are exhausted.
If there is no <em class="replaceable"><code>value</code></em>, the initial contents of each element is
unspecified.
The array does not retain a reference to <em class="replaceable"><code>shape</code></em>.
</p>
<pre class="screen"><strong class="userinput"><code>(make-array #(2 4) 1 2 3 4 5)</code></strong> &#x21e8;
╔#2a:2:4╗
║1│2│3│4║
╟─┼─┼─┼─╢
║5│1│2│3║
╚═╧═╧═╧═╝
</pre>
<p><span class="emphasis"><em>Compatibility:</em></span> Guile has an incompatible <code class="literal">make-array</code> procedure.
</p>
</blockquote></div>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">build-array<span></code> <var>shape</var> <var>procedure</var><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Construct a “virtual array” of the given <em class="replaceable"><code>shape</code></em> that uses no storage for the elements.
Instead, elements are calculated on demand by calling <em class="replaceable"><code>procedure</code></em>,
which takes a single argument, an index vector.
</p>
<p>There is no caching or memoization.
</p>
<pre class="screen"><strong class="userinput"><code>(build-array #2a((10 12) (0 3))</code></strong>
<strong class="userinput"><code>  (lambda (ind)</code></strong>
<strong class="userinput"><code>    (let ((x (ind 0)) (y (ind 1)))</code></strong>
<strong class="userinput"><code>      (- x y))))</code></strong> &#x21e8;
#2a@10:2:3
║10│ 9│8║
╟──┼──┼─╢
║11│10│9║
╚══╧══╧═╝
</pre>
</blockquote></div>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">index-array</span></code> <var>shape</var><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Return a new immutable array of the specified <em class="replaceable"><code>shape</code></em>
where each element is the corresponding row-major index.
Same as <code class="literal">(array-reshape (range-take <var>size</var>) <var>shape</var>)</code>
where <em class="replaceable"><code>size</code></em> is the <code class="literal">array-size</code> of the resulting array.
</p>
<pre class="screen"><strong class="userinput"><code>(index-array #2a((1 3) (2 6)))</code></strong> &#x21e8;
#2a@1:2@2:4
║0│1│2│3║
╟─┼─┼─┼─╢
║4│5│6│7║
╚═╧═╧═╧═╝
</pre>
</blockquote></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Array-indexing"></a>Array indexing</h3></div></div></div>
<p>Given a rank-2 array <em class="replaceable"><code>arr</code></em> with integer indexes <em class="replaceable"><code>i</code></em>
and <em class="replaceable"><code>j</code></em>, the following all get the element of <em class="replaceable"><code>arr</code></em>
at index <code class="literal">[<em class="replaceable"><code>i</code></em> <em class="replaceable"><code>j</code></em>]</code>.
</p>
<pre>
(array-index-ref <var>arr</var> <var>i</var> <var>j</var>)
(array-ref <var>arr</var> <var>i</var> <var>j</var>)
(array-ref <var>arr</var> (vector <var>i</var> <var>j</var>))
</pre>
<p>Using <code class="literal">array-index-ref</code>
(but not plain <code class="literal">array-ref</code>) you can do generalized APL-style
slicing and indirect indexing.
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">array-ref</span></code> <var>array</var> <var>k</var> <var>...</var><code>)</code></p>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">array-ref</span></code> <em class="replaceable"><code>array</code></em> <em class="replaceable"><code>index</code></em><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Returns the contents of the element of <em class="replaceable"><code>array</code></em> at index <em class="replaceable"><code>k</code></em> ....
The sequence <em class="replaceable"><code>k</code></em> ... must be a valid index to <em class="replaceable"><code>array</code></em>.
In the second form, <em class="replaceable"><code>index</code></em> must be a vector
(a 0-based 1-dimensional array) containing <em class="replaceable"><code>k</code></em> ....
</p>
<pre class="screen">(array-ref (array [2 3]
              'uno 'dos 'tres
              'cuatro 'cinco 'seis)
   1 0)
</pre>
<p>Returns <code class="literal">cuatro</code>.
</p>
<pre class="screen">(let ((a (array (shape 4 7 1 2) 3 1 4)))
   (list (array-ref a 4 1)
         (array-ref a (vector 5 1))
         (array-ref a (array (shape 0 2)
                         6 1))))
</pre>
<p>Returns <code class="literal">(3 1 4)</code>.
</p>
</blockquote></div>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">array-index-ref</span></code> <em class="replaceable"><code>array</code></em> <em class="replaceable"><code>index</code></em> <var>...</var><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Generalized APL-style array indexing, where each <em class="replaceable"><code>index</code></em>
can be either an array or an integer.
</p>
<p>If each <var>index</var> is an integer,
or there is no <var>index</var>,
then the result is the same as <code class="literal">array-ref</code>.
</p>
<p>Otherwise, the result is an immutable array whose rank is the sum of the ranks of
each <em class="replaceable"><code>index</code></em>.  An integer is treated as rank-0 array.
The shape of the result is the <q>concatenation</q> of the shapes of
indexes: The lowers bounds is the concatenation of the lower bounds
of the indexes, and similar for the upper bounds.
(If an index is an unbounded range, it is truncated as needed to not
cause an error.)
</p>
<p>If <em class="replaceable"><code>marr</code></em> is the result of <code class="literal">(array-index-ref <em class="replaceable"><code>arr</code></em> <em class="replaceable"><code>M<sub>1</sub></code></em> <em class="replaceable"><code>M<sub>2</sub></code></em> ...)</code> then:
</p>
<pre class="screen">(array-ref <var>marr</var> <em class="replaceable"><code>i<sub>11</sub></code></em> <em class="replaceable"><code>i<sub>12</sub></code></em> ... <em class="replaceable"><code>i<sub>21</sub></code></em> <em class="replaceable"><code>i<sub>22</sub></code></em> ...)
</pre>
<p>is defined as:
</p>
<pre class="screen">(array-ref <em class="replaceable"><code>arr</code></em> (array-ref <em class="replaceable"><code>M<sub>1</sub></code></em> <em class="replaceable"><code>i<sub>11</sub></code></em> <em class="replaceable"><code>i<sub>12</sub></code></em> ...) (array-ref <em class="replaceable"><code>M<sub>2</sub></code></em> <em class="replaceable"><code>i<sub>21</sub></code></em> <em class="replaceable"><code>i<sub>22</sub></code></em> ...) ...)
</pre>
<p>Each <em class="replaceable"><code>M<sub>k</sub></code></em> gets as many indexes as its rank.
If <em class="replaceable"><code>M<sub>k</sub></code></em> is an integer, then it we use
it directly without any indexing, as if it were a rank-0 array.
</p>
<p>
The resulting array <var>marr</var> is a fresh array
that does not depend on any of the arguments.
Specifically, if <code>array-ref</code> is called on <var>marr</var>
with valid indexes (within its shape), then no error is possible;
any potentially invalid indexes must be caught by <code>array-index-ref</code>.
<p>Here are some examples, starting with simple indexing.
</p>
<pre class="screen"><strong class="userinput"><code>(define arr (array #2a((1 4) (0 4))</code></strong>
<strong class="userinput"><code>                   10 11 12 13 20 21 22 23 30 31 32 33))</code></strong>
<strong class="userinput"><code>arr</code></strong> &#x21e8;
╔#2a@1:3:4══╗
║10│11│12│13║
╟──┼──┼──┼──╢
║20│21│22│23║
╟──┼──┼──┼──╢
║30│31│32│33║
╚══╧══╧══╧══╝
<strong class="userinput"><code>(array-index-ref arr 2 3)</code></strong> &#x21e8;
23
</pre>
<p>If one index is a vector and the rest are scalar integers,
then the result is a vector:
</p>
<pre class="screen"><strong class="userinput"><code>(array-index-ref arr 2 #(3 1))</code></strong> &#x21e8;
#(23 21)
</pre>
<p>You can select a “sub-matrix” when all indexes are vectors:
</p>
<pre class="screen"><strong class="userinput"><code>(array-index-ref arr #(2 1) #(3 1 3))</code></strong> &#x21e8;
╔#2a:2:3═╗
║23│21│23║
╟──┼──┼──╢
║13│11│13║
╚══╧══╧══╝
</pre>
<p>Using ranges for index vectors selects a rectangular sub-matrix.
</p>
<pre class="screen"><strong class="userinput"><code>(array-index-ref arr (range&lt; 3 1) (range&lt; 4 1))</code></strong> &#x21e8;
╔#2a:2:3═╗
║11│12│13║
╟──┼──┼──╢
║21│22│23║
╚══╧══╧══╝
</pre>
<p>You can add new dimensions:
</p>
<pre class="screen"><strong class="userinput"><code>(array-index-ref arr #(2 1) #2a((3 1) (3 2)))</code></strong> &#x21e8;
#3a╤══╗
║23│21║
╟──┼──╢
║23│22║
╠══╪══╣
║13│11║
╟──┼──╢
║13│12║
╚══╧══╝
</pre>
<p><em>FIX: Need alternate non-Kawa way to expression pseudo-ranges.</em>
The pseudo-range <code class="literal">[&lt;:]</code> can be used to select all the indexes
along a dimension.  To select row 2 (1-origin):
</p>
<pre class="screen"><strong class="userinput"><code>(array-index-ref arr 2 [&lt;:])</code></strong> &#x21e8;
#(20 21 22 23)
</pre>
<p>To reverse the order use <code class="literal">[&gt;:]</code>:
</p>
<pre class="screen"><strong class="userinput"><code>(array-index-ref arr 2 [&gt;:])</code></strong> &#x21e8;
#(23 22 21 20)
</pre>
<p>To select column 3:
</p>
<pre class="screen"><strong class="userinput"><code>(array-index-ref arr [&lt;:] [3])</code></strong> &#x21e8;
#2a╗
║13║
╟──╢
║23║
╟──╢
║33║
╚══╝
</pre>
<p>To expand that column to 5 columns you can repeat the column index:
</p>
<pre class="screen"><strong class="userinput"><code>(range-take 5 3 0)</code></strong>
#(3 3 3 3 3)
<strong class="userinput"><code>(array-index-ref arr [&lt;:] (range-take 5 3 0))</code></strong> &#x21e8;
╔#2a:3:5═╤══╤══╗
║13│13│13│13│13║
╟──┼──┼──┼──┼──╢
║23│23│23│23│23║
╟──┼──┼──┼──┼──╢
║33│33│33│33│33║
╚══╧══╧══╧══╧══╝
</pre>
</blockquote></div>
</div>
<div class="sect2"><h3 class="title" id="Modifying-arrays">Modifying arrays</h3>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">array-set!<span></code> <var>array</var> <var>k</var> <var>...</var> <var>obj</var><code>)</code></p>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">array-set!</span></code> <var>array</var> <var>index</var> <var>obj</var><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Stores <em class="replaceable"><code>obj</code></em> in the element of <em class="replaceable"><code>array</code></em> at index <em class="replaceable"><code>k</code></em> ....
Returns the void value.
The sequence <em class="replaceable"><code>k</code></em> ... must be a valid index to <em class="replaceable"><code>array</code></em>.
In the second form, <em class="replaceable"><code>index</code></em> must be either a vector or a
0-based 1-dimensional array containing <em class="replaceable"><code>k</code></em> ....
</p>
<pre class="screen">(let ((a (make-array
            (shape 4 5 4 5 4 5))))
   (array-set! a 4 4 4 "huuhkaja")
   (array-ref a 4 4 4))
</pre>
<p>Returns <code class="literal">"huuhkaja"</code>.
</p>
<p><span class="emphasis"><em>Compatibility:</em></span> SRFI 47, Guile and Scheme-48 have <code class="literal">array-set!</code> with a
different argument order.
</p>
</blockquote></div>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">array-copy!</span></code> <var>dst</var> <var>src</var><code>)</code></p>

<div class="blockquote"><blockquote class="blockquote"><p>Both arguments must have the same shape.
Every element in <var>dst</var> is replaced by the corresponding
element in <var>src</var>.</p>
<p><span class="emphasis"><em>Compatibility:</em></span> Guile has an <code class="literal">array-copy!</code> with the reversed
argument order.
</p></blockquote></div>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">array-fill!<span></code> <var>array</> <var>value</var><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote"><p>Set all the values <em class="replaceable"><code>array</code></em> to <em class="replaceable"><code>value</code></em>.
You can use <code>(array-fill! (array-index-share <em class="replaceable"><code>array</code></em> <em class="replaceable"><code>indexes</code></em>...) <em class="replaceable"><code>value</code></em>)</code> to set a subset of the array.
</p></blockquote></div>
</div>
<div class="sect2"><h3 class="title" id="array-as-procedure">Array as procedure (non-normative)</h3>
An optional extension (implemented in Kawa) is to allow
<q>applying</q> a vector or array as a procedure.
In such an implementation <code>(<var>vec</var> <var>i</var>)</code>
is the same as <code>(vector-ref <var>vec</var> <var>i</var>)</code>,
and it is suggested that
<code>(<var>array</var> <var>index</var> ...)</code> should be
equivalent to <code>(array-index-ref <var>array</var> <var>index</var> ...)</code>.
<p>An implementation that also supports <a href="https://srfi.schemers.org/srfi-17/srfi-17.html">SRFI 17 (generalized <code>set!</code>)</a>
should allow <code class="literal">set!</code> to modify one or multiple elements.
To modify a single element:
</p>
<pre class="screen">(set! (<em class="replaceable"><code>arr</code></em> <em class="replaceable"><code>index</code></em> ...) <em class="replaceable"><code>new-value</code></em>)
</pre>
<p>should be equivalent to:
</p>
<pre class="screen">(array-set! <em class="replaceable"><code>arr</code></em> <em class="replaceable"><code>index</code></em> ... <em class="replaceable"><code>new-value</code></em>)
</pre>
<p>You can set a slice (or all of the elements).
In that case:
</p>
<pre class="screen">(set! (<em class="replaceable"><code>arr</code></em> <em class="replaceable"><code>index</code></em> ...) <em class="replaceable"><code>new-array</code></em>)
</pre>
<p>is equivalent to:
</p>
<pre class="screen">(array-copy! (array-index-share <em class="replaceable"><code>arr</code></em> <em class="replaceable"><code>index</code></em> ...) <em class="replaceable"><code>new-array</code></em>)
</pre>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Transformations-and-views"></a>Transformations and views</h3></div></div></div>
<p>A view or transform of an array is an array <em class="replaceable"><code>a<sub>2</sub></code></em>
whose elements come from some other array <em class="replaceable"><code>a<sub>1</sub></code></em>
given some transform function <em class="replaceable"><code>T</code></em> that maps <em class="replaceable"><code>a<sub>2</sub></code></em> indexes
to <em class="replaceable"><code>a<sub>1</sub></code></em> indexes.
Specifically, <code class="literal">(array-ref <em class="replaceable"><code>a<sub>2</sub></code></em> <em class="replaceable"><code>indexes</code></em>)</code>
is <code class="literal">(array-ref <em class="replaceable"><code>a<sub>1</sub></code></em> (<em class="replaceable"><code>T</code></em> <em class="replaceable"><code>indexes</code></em>))</code>.
Modifying <em class="replaceable"><code>a<sub>2</sub></code></em> causes <em class="replaceable"><code>a<sub>1</sub></code></em> to be modified;
modifying <em class="replaceable"><code>a<sub>1</sub></code></em> may modify <em class="replaceable"><code>a<sub>2</sub></code></em>
(depending on the transform function).
The shape of <em class="replaceable"><code>a<sub>2</sub></code></em> is in general different than that of <em class="replaceable"><code>a<sub>1</sub></code></em>.
The result <em class="replaceable"><code>a<sub>2</sub></code></em> is
mutable if and only if <em class="replaceable"><code>a<sub>1</sub></code></em>
is, with the same element type restrictions, if any.
</p>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">array-transform</span></code> <var>array</var> <var>shape</var> <var>transform</var><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote">
<p>This is a general mechanism for creating a view.
The result is a new array with the given <em class="replaceable"><code>shape</code></em>.
Accessing this new array is implemented by calling the <em class="replaceable"><code>transform</code></em>
function on the index vector, which must return a new index vector
valid for indexing the original <em class="replaceable"><code>array</code></em>.
Here is an example (using the same <code class="literal">arr</code> as in
the <code class="literal">array-index-ref</code> example):
</p>
<pre class="screen"><strong class="userinput"><code>(define arr (array #2a((1 4) (0 4))</code></strong>
<strong class="userinput"><code>                   10 11 12 13 20 21 22 23 30 31 32 33))</code></strong>
<strong class="userinput"><code>(array-transform arr #2a((0 3) (1 3) (0 2))</code></strong>
<strong class="userinput"><code>  (lambda (ix) (let ((i (ix 0)) (j (ix 1)) (k (ix 2)))</code></strong>
<strong class="userinput"><code>                 [(+ i 1)</code></strong>
<strong class="userinput"><code>                  (+ (* 2 (- j 1)) k)])))</code></strong> &#x21e8;
#3a:3@1:2:2
║10│11║
╟──┼──╢
║12│13║
╠══╪══╣
║20│21║
╟──┼──╢
║22│23║
╠══╪══╣
║30│31║
╟──┼──╢
║32│33║
╚══╧══╝
</pre>
<p>The <code class="literal">array-transform</code> procedure is a generalization of <code class="literal">share-array</code>
in that it does not require the <em class="replaceable"><code>transform</code></em> to be affine.
Also note the different calling conversions for the <em class="replaceable"><code>tranform</code></em>:
<code class="literal">array-transform</code> takes a single argument (a vector of indexes),
and returns a single result (a vector of indexes);
<code class="literal">share-array</code> takes one argument for each index, and returns
one value for each index.  The difference is historical.
</p>
</blockquote></div>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">array-index-share</span></code> <var>array</var> <var>index</var> <var>...</var><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote"><p>This does the same generalized APL-style indexing
as <code class="literal">array-index-ref</code>.  However, the resulting array
is a modifiable view into the argument <em class="replaceable"><code>array</code></em>.
If each index is an integer, the result is a rank-0 array
that is a view of the selected element
(unlike <code class="literal">array-index-ref</code>
which would return the selected element directly).
</p></blockquote></div>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def" id="array-reshape">array-reshape<span></code> <var>array</var> <var>shape</var>)</code></p>
<div class="blockquote"><blockquote class="blockquote"><p>Creates a new array <em class="replaceable"><code>narray</code></em> of the given <em class="replaceable"><code>shape</code></em>,
such that <code class="literal">(array-&gt;vector <em class="replaceable"><code>array</code></em>)</code> and
<code class="literal">(array-&gt;vector <em class="replaceable"><code>narray</code></em>)</code> are equivalent.
In other words, the <em class="replaceable"><code>i</code></em>’th element in row-major-order of <em class="replaceable"><code>narray</code></em>
is the <em class="replaceable"><code>i</code></em>’th element in row-major-order of <em class="replaceable"><code>array</code></em>.
Hence <code class="literal">(array-size <em class="replaceable"><code>narray</code></em>)</code> (as specified from the <em class="replaceable"><code>shape</code></em>)
must be equal to <code class="literal">(array-size <em class="replaceable"><code>array</code></em>)</code>.
The resulting <em class="replaceable"><code>narray</code></em> is a view such that modifying <em class="replaceable"><code>array</code></em>
also modifies <em class="replaceable"><code>narray</code></em> and vice versa.
</p></blockquote></div>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">share-array</span></code> <var>array</var> <var>shape</var> <var>proc</var><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Returns a new array of <em class="replaceable"><code>shape</code></em> shape that shares elements of <em class="replaceable"><code>array</code></em>
through <em class="replaceable"><code>proc</code></em>. The procedure <em class="replaceable"><code>proc</code></em> must implement an affine
function that returns indices of <em class="replaceable"><code>array</code></em> when given indices of the
array returned by <code class="literal">share-array</code>.
The array does not retain a reference to <em class="replaceable"><code>shape</code></em>.
</p>
<pre class="screen">(define i_4
   (let* ((i (make-array
                (shape 0 4 0 4)
                0))
          (d (share-array i
                (shape 0 4)
                (lambda (k)
                   (values k k)))))
      (do ((k 0 (+ k 1)))
          ((= k 4))
         (array-set! d k 1))
      i))
</pre>
<p>Note: the affinity requirement for <em class="replaceable"><code>proc</code></em> means that each value must
be a sum of multiples of the arguments passed to <em class="replaceable"><code>proc</code></em>, plus a constant.
</p>
<p>Implementation note: arrays have to maintain an internal index mapping
from indices <em class="replaceable"><code>k1</code></em> ... <em class="replaceable"><code>kd</code></em> to a single index into a backing vector;
the composition of this mapping and <em class="replaceable"><code>proc</code></em> can be recognised
as <code class="literal">(<em class="replaceable"><code>+ n0</code></em> (* <em class="replaceable"><code>n1</code></em> <em class="replaceable"><code>k1</code></em>) ... (* <em class="replaceable"><code>nd</code></em> <em class="replaceable"><code>kd</code></em>))</code>
by setting each index in turn to 1 and others to 0,
and all to 0 for the constant term; the composition can then be compiled
away, together with any complexity that the user introduced in their
procedure.
</p>
<p>Here is an example where the <em class="replaceable"><code>array</code></em> is a uniform vector:
</p>
<pre class="screen">(share-array
  (f64vector 1.0 2.0 3.0 4.0 5.0 6.0)
  (shape 0 2 0 3)
  (lambda (i j) (+ (* 2 i) j)))
   &#x21e8;  #2f64((1.0 2.0 3.0) (4.0 5.0 6.0))
</pre>
</blockquote></div>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">array-flatten</span></code> <var>array</var><code>)</code></p>
<p class="synopsis" kind="Procedure"><code class="function">(<span class="proc-def">array-&gt;vector</span></code> <var>array</var><code>)</code></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Return a vector consisting of the elements of the <em class="replaceable"><code>array</code></em>
in row-major-order.
</p>
<p>The result of <code class="literal">array-flatten</code> is a fresh (mutable) copy, not a view.
The result of <code class="literal">array-&gt;vector</code> is a view: If <em class="replaceable"><code>array</code></em> is mutable,
then modifying <em class="replaceable"><code>array</code></em> changes the flattened result and vice versa.
</p>
<p>If <em class="replaceable"><code>array</code></em> is “simple”,  <code class="literal">array-&gt;vector</code> returns the original vector.
Specifically, if <em class="replaceable"><code>vec</code></em> is a vector then:
</p>
<pre class="screen">(eq? <em class="replaceable"><code>vec</code></em> (array-&gt;vector (array-reshape <em class="replaceable"><code>vec</code></em> <em class="replaceable"><code>shape</code></em>)))
</pre>
</blockquote></div>
</div>

<h1>Implementation</h1>
<p>
The following describes how this API is implemented
in <a href="https://www.gnu/orh/software/kawa">Kawa</a>.
The implementation is a mix of Java and the Kawa dialect of Scheme.
This overview should be enough to implement the specification,
but studying the Kawa implementation adds useful detail.
<!--
The Kawa implementation has a number of extra methods
to avoid object allocation, both of index vectors, and when
extracting immediate values from uniform arrays.
(There are also special classes and methods for vectors.)
For simplicity, we will ignore those optimizations here,
and assume all vectors and arrays are general object arrays.--></p>
<p>
A simple vector (the abstract class <code>SimpleVector</code>) is a wrapper
around a simple fixed-size native array of the appropriate type.
There are sub-classes for different element types:
General (simple) vectors (the class <code>FVector</code> which
extends <code>SimpleVector</code>) uses an object array (<code>Object[]</code>),
while an F32 vector (the class <code>F32Vector</code>)
uses an array of floats (a <code>float[]</code>).</p>
<p>
By default, there is a 1-to-1 mapping from the vector index
to the index in the native array, but in some cases the
mapping can be slightly more complex:
A mutable vector may change its length, and this is implemented
as a <a href="https://en.wikipedia.org/wiki/Gap_buffer">gap buffer</a>,
so the index calculation must adjust for the unused elements in the gap.
A slice (sub-vector) may share the underlying native array with another
vector, so the index calculation must adjust for the start offset.</p>
<p>
Therefore we separate the index mapping logic
(method <code>effectiveIndex</code>)
from the code for accessing the native array (<code>getRaw</code>).
Thus <code>(vector-ref vec i)</code> is implemented
as <code>vec.get(i)</code>, which in turn is implemented as
<code>vec.getRaw(vec.effectiveIndex(i))</code>.</p>
<p>
Mutating an element is similar:
<code>(vector-set! vec i value)</code> is implemented
as <code>vec.set(i, value)</code>, which in turn is implemented as
<code>vec.setRaw(vec.effectiveIndex(i), value)</code>.
In the following, for simplicity we'll mostly ignore mutation.</p>
<p>
The same logic is used for uniform vectors.
An F32 vector (<code>F32Vector</code>) additionally has
<code>getFloat</code> and <code>getFloatRaw</code> methods
that return unboxed <code>float</code> values.
The <code>vec.getFloat(i)</code> method is
<code>vec.getFloatRaw(vec.effectiveIndex(i))</code>.
If the compiler knows it is dealing with an F32 vector,
it generates a call to <code>getFloat</code>, avoiding boxing.
For simplicity we'll mostly ignore uniform vectors in the following,
but non-vector arrays can be similarly optimized.</p>
<p>
All arrays (including vectors) implement the <code>Array</code> interface.
The <code>get</code> method is generalized to take
an array of indexes, but is still uses <code>effectiveIndex</code>,
but generalized to take a vector of indexes (actually <code>int[]</code>,
a native <code>int</code> array).
Thus <code>arr.get(ivec)</code> is still
<code>arr.getRaw(arr.effectiveIndex(ivec))</code>.</p>
<p>
With a few exceptions (such as the result of <code>build-array</code>)
arrays that are not vectors are represented as
transformations of other arrays, usually simple vectors,
using the abstract class <code>TranformedArray</code>.
In this case <code>getRaw</code> indirects to the base array:
<code>arr.getRaw(effi)</code> is <code>arr.base.getRaw(effi)</code>,
and therefore <code>arr.get(ivec)</code> is
<code>arr.base.getRaw(arr.effectiveIndex(ivec))</code>.</p>
<p>
Both the <code>get</code> and <code>effectiveIndex</code> methods
are overloaded to take 0, 1, 2, or <q>many</q> indexes.
The is to avoid having to allocate an index array unncessarily,
but in the following we'll ignore this optimization.</p>
<p>
A <code>GeneralArray</code> is a <code>TransformedArray</code>
that takes a <code>base</code> array along with an <code>offset</code>
and a <code>stride</code> vector.
The <code>effectiveIndex</code> multiples each index by the
corresponding <code>stride</code>, adds the <code>offset</code>, and then
uses the result to call <code>effectiveIndex</code> on the <code>base</code>.
A simple non-vector array, as allocated by the <code>make-array</code>
or the <code>array</code> procedures returns a <code>GeneralArray</code>,
using as the <code>base</code> a simple vector containing the
elements in row-major order.
The <code>share-array</code> procedure returns a <code>GeneralArray</code>.
The bounds and strides are calculated from the <var>shape</var>
and <var>proc</var>.
If the argument <var>array</var> is a <code>GeneralArray</code>,
the latter's <code>base</code> is used as an optimization.
</p>
<p>
The general case of <code>array-index-share</code> returns
a <code>ComposedArray</code>, which is a <code>TransformedArray</code>
that has a reference to the index arrays as well as the base array.
See the <code>resolve</code> method in <code>ComposedArray.java</code>
for the calculation used by <code>effectiveIndex</code>.
If all of the indexes are <q>linear</q> (simple integers or integer ranges)
then the result is optimized to a <code>GeneralArray</code>.</p>
The implementation of <code>array-index-ref</code> is basically
doing <code>index-array-share</code> and then making a simple
(<code>GeneralArray</code>) immutale copy of the result.
However, there are some optimizations and special cases.
To implement <code>index-array</code> we just
wrap a <code>GeneralArray</code> around a simple range.</p>
<p>
The result of <code>array-transform</code> is a
<code>ProcTransformedArray</code>, which is a <code>TransformedArray</code>
that calls the supplied <var>transform</var> procedure
in the <code>effectiveIndex</code> method.</p>
<p>
A <code>FlattenedArray</code> is used to implement
<code>array-&gt;vector</code>.
It is a <code>TransformedArray</code> whose <code>effectiveIndex</code>
maps the argument index to the raw-major-order effective index
of the <code>base</code> array.  If the argument array is a <q>simple</q>
<code>GeneralArray</code> (that wrapes a <code>SimpleVector</code>)
it returns the latter's <code>base</code>, as an optimization.
The <code>array-reshape</code> procedure first creates a
<code>FlattenedArray</code> from the argument, and then
wraps that in a <code>GeneralArray</code>.
Implementing <code>array-flatten</code> is just creating a fresh
mutable vector (possible a uniform vector) and then copying the
elements in row-major order.</p>
<p>
The <code>BuiltArray</code> class (which does <em>not</em> extend
<code>TranformedArray</code>) is used to implement <code>build-array</code>
by having <code>get</code> call the <var>procedure</var> on each access.

<h1>Acknowledgements</h1>

<h1>Copyright</h1>
<p>
Copyright (C) Per Bothner 2018</p>
<p>
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:</p>
<p>
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.</p>
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<hr>
<address>Author: <a href="mailto:per@bothner.com">Per Bothner</a></address>
